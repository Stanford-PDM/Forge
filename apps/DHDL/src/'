import dhdl.compiler._
import dhdl.library._
import dhdl.shared._
import scala.util.Random
import scala.collection.mutable.PriorityQueue

object KNNCompiler extends DHDLApplicationCompiler with KNN 
object KNNInterpreter extends DHDLApplicationInterpreter with KNN

trait KNNTest {
	def test (sPoints:Seq[Seq[Float]], sLabels:Seq[Int], sTests:Seq[Seq[Float]], sK:Int): Seq[Int] = {
		val sDim = sPoints(0).length
		def dist(p1:Seq[Float], p2:Seq[Float]):Float = {
			p1.zip(p2).map{case (d1, d2) => (d1-d2)*(d1-d2)}.reduce(_+_)
		}

		val gold = sTests.map{ t =>
			val pq = new PriorityQueue[(Float, Int)]()(
				Ordering.by{ case (dist,label) => -dist })
			sPoints.zipWithIndex.foreach { p =>
				dist(t, p)
			}
		}

		//println("points:")
		//println(sPoints.map(p => p.mkString(",")).mkString("\n"))
		//println("cents:")
		//println(sCents.map(c => c.mkString(",")).mkString("\n"))
		//println("newCents:")
		//println(gold.map(c => c.mkString(",")).mkString("\n"))

		gold
	}
}
trait KNN extends DHDLApplication with KNNTest{
	def printUsage = {
    println("Usage: knn")
    exit(-1)
	}
  def main() = {
		val tileSize = 4
		val sDim = 4
		val sNumPoints = 16
		val sK = 4
		val sNumTest = 2

		val sPoints = Seq.tabulate(sNumPoints){i =>
			Seq.tabulate(sDim){d => 
				Random.nextFloat()*100f
			}
		}
		val sTests = Seq.tabulate(sNumTest){i =>
			Seq.tabulate(sDim){d => 
				Random.nextFloat()*100f
			}
		}
		val sLabels = Seq.tabulate(sNumPoints) {i => i}

		val gold = test(sPoints, sLabels, sTests, sK)

		val numPoints = ArgIn[FixPt](sNumPoints).value
		val numCents = ArgIn[FixPt](sNumCents).value

		val points = OffChipMem[Float](sPoints.flatten.map(i => unit(i)): _*)
		val oldCents = BRAM[Float](sNumCents, sDim)
		val newCents = BRAM[Float](sNumCents, sDim)
		val centCount = BRAM[FixPt](sNumCents)
		points.ld(oldCents, 0, sNumCents*sDim)

		MetaPipe {
			val tileCtr = CounterChain(Counter(max=numPoints, step=tileSize))
			val pointsB = BRAM[Float](tileSize, sDim)
			Sequential(tileCtr) { case iTile::_ => 
				points.ld(pointsB, iTile*sDim, tileSize*sDim)
				val ptCtr = CounterChain(Counter(max=tileSize))
				val minDist = Reg[Float](-1f)
				val minCent = Reg[FixPt](0)
				Sequential(ptCtr) { case iP::_ =>
					//TODO; this should be a reduce on two regs
					minDist.reset
					minCent.reset
					val ctCtr = CounterChain(Counter(max=numCents))
					MetaPipe(true, ctCtr) { case iC::_ =>
						val dimCtr = CounterChain(Counter(max=sDim))
						val dist = Reg[Float](0)
						Pipe[Float](dimCtr, dist, _+_) { case iD::_ =>
							(pointsB.ld(iP, iD) - oldCents.ld(iC, iD)).pow(2)
						}
						val closer = (dist.value < minDist.value) || (minDist.value < unit(0f))
						minDist.write(mux(closer, dist.value, minDist.value))
						minCent.write(mux(closer, iC, minCent.value))
					}
					//TODO: following should be in reduction function
					Parallel {
						val dimCtr = CounterChain(Counter(max=sDim))
						Pipe(dimCtr) { case iD::_ =>
							newCents.st(minCent.value, iD,
								pointsB.ld(iP, iD) + newCents.ld(minCent.value, iD)) 
						}
						centCount.st(minCent.value, centCount.ld(minCent.value) + FixPt(1))
					}
				}
			}
			val newCentCtr = CounterChain(Counter(max=numCents), Counter(max=sDim))
			Pipe(newCentCtr) {case iC::iD::_ =>
				newCents.st(iC, iD, newCents.ld(iC, iD)/centCount.ld(iC).toFloat)
			}
		}
		//println("DHDL:")
		//println("points")
		//println(points.mkString)
		//println("cents")
		//println(newCents.mkString)
		val fgold = gold.flatten
		fgold.zipWithIndex.foreach{case (g, i) => 
			assert(unit(g) == newCents.ld(i))
		}
	}
}
