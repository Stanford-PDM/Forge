
.. role:: black
.. role:: gray
.. role:: silver
.. role:: white
.. role:: maroon
.. role:: red
.. role:: fuchsia
.. role:: pink
.. role:: orange
.. role:: yellow
.. role:: lime
.. role:: green
.. role:: olive
.. role:: teal
.. role:: cyan
.. role:: aqua
.. role:: blue
.. role:: navy
.. role:: purple

.. _MetaPipe:

MetaPipe
========

<auto-generated stub>

Static methods
--------------

.. parsed-literal::

  :maroon:`def` apply(x: :doc:`counter`)(y: (:doc:`Index <fixpt>`) => Unit): Unit




*********

.. parsed-literal::

  :maroon:`def` apply(x: :doc:`counter`, y: :doc:`counter`)(z: (:doc:`Index <fixpt>`, :doc:`Index <fixpt>`) => Unit): Unit




*********

.. parsed-literal::

  :maroon:`def` apply(x: :doc:`counter`, y: :doc:`counter`, z: :doc:`counter`)(v: (:doc:`Index <fixpt>`, :doc:`Index <fixpt>`, :doc:`Index <fixpt>`) => Unit): Unit




*********

.. parsed-literal::

  :maroon:`def` apply(x: :doc:`counter`, y: C\[T\])(z: (:doc:`Index <fixpt>`) => T)(v: (T, T) => T)(:maroon:`implicit` ev0: Mem[T,C],ev1: Manifest[C\[T\]]): Unit




*********

.. parsed-literal::

  :maroon:`def` apply(x: :doc:`counter`, y: :doc:`counter`, z: C\[T\])(v: (:doc:`Index <fixpt>`, :doc:`Index <fixpt>`) => T)(w: (T, T) => T)(:maroon:`implicit` ev0: Mem[T,C],ev1: Manifest[C\[T\]]): Unit




*********

.. parsed-literal::

  :maroon:`def` apply(x: :doc:`counter`, y: :doc:`counter`, z: :doc:`counter`, v: C\[T\])(w: (:doc:`Index <fixpt>`, :doc:`Index <fixpt>`, :doc:`Index <fixpt>`) => T)(a: (T, T) => T)(:maroon:`implicit` ev0: Mem[T,C],ev1: Manifest[C\[T\]]): Unit




*********

.. parsed-literal::

  :maroon:`def` apply(x:  => Unit): Unit




*********

.. parsed-literal::

  :maroon:`def` foreach(x: :doc:`counterchain`)(y: (:doc:`indices`) => Unit): Unit




*********

.. parsed-literal::

  :maroon:`def` reduce(x: :doc:`counterchain`, y: C\[T\])(z: (:doc:`indices`) => T)(v: (T, T) => T)(:maroon:`implicit` ev0: Mem[T,C],ev1: Manifest[C\[T\]]): Unit




Related methods
---------------

.. parsed-literal::

  :maroon:`def` BlockReduce(x: :doc:`counter`, y: :doc:`bram`\[T\])(z: (:doc:`Index <fixpt>`) => :doc:`bram`\[T\])(v: (T, T) => T): Unit




*********

.. parsed-literal::

  :maroon:`def` BlockReduce(x: :doc:`counter`, y: :doc:`counter`, z: :doc:`bram`\[T\])(v: (:doc:`Index <fixpt>`, :doc:`Index <fixpt>`) => :doc:`bram`\[T\])(w: (T, T) => T): Unit




*********

.. parsed-literal::

  :maroon:`def` BlockReduce(x: :doc:`counter`, y: :doc:`counter`, z: :doc:`counter`, v: :doc:`bram`\[T\])(w: (:doc:`Index <fixpt>`, :doc:`Index <fixpt>`, :doc:`Index <fixpt>`) => :doc:`bram`\[T\])(a: (T, T) => T): Unit




*********

.. parsed-literal::

  :maroon:`def` BlockReduce(x: :doc:`counter`, y: :doc:`bram`\[T\], z: Int)(v: (:doc:`Index <fixpt>`) => :doc:`bram`\[T\])(w: (T, T) => T): Unit




*********

.. parsed-literal::

  :maroon:`def` Parallel(x:  => Unit): Unit




*********

.. parsed-literal::

  :maroon:`def` block\_reduce\_create(x: :doc:`counterchain`, y: Int, z: :doc:`bram`\[T\], v: (:doc:`indices`) => :doc:`bram`\[T\], w: (T, T) => T): Unit




