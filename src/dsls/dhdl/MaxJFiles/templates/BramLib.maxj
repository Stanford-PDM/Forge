package engine;

import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.SMIO;
import com.maxeler.maxcompiler.v2.utils.MathUtils;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;

/*
 * @BramLib: Library that creates Block RAM with multiple banks
 * TODO: Parameterize this library to support the following:
 *  1. Simple dual port: One address stream with write enable
 *  2. Read-only: ROM
 *  3. Support strided interleaving. Currently only round-robin interleaving
 *  is supported - successive words map to different banks.
 */
class BramLib extends KernelLib {

  int addrBits;
  int banks;
  int stride;
  int size;
  DFEType type;
  BoxedMem[] m;

  boolean dbg = false;

  void common(int size, DFEType type, int banks, int stride) {
    this.addrBits = MathUtils.bitsToAddress(size);
    this.type = type;
    this.size = size;
    this.banks = banks;
    this.stride = stride;
    m = new BoxedMem[banks];
    for (int i=0; i<banks; i++) {
      m[i] = new BoxedMem(this, type, size/banks);
    }
  }

  BramLib(KernelLib owner, int size, DFEType type, int banks, int stride) {
    super(owner);
    common(size, type, banks, stride);
  }

  BramLib(KernelLib owner, int size, DFEType type, int banks) {
    super(owner);
    common(size, type, banks, 1);
  }

  BramLib(KernelLib owner, int size, DFEType type) {
    super(owner);
    common(size, type, 1, 1);
  }

  /**
   *  Enum to distinguish between what kind of address is required
   *  from bankAndLocalAddr.
   */
  public enum AddrMode {
     BANK,
     LOCAL
  }

  /**
   *  Calculating bank address and local address within a bank
   *  using a single divider.
   *  @param srcAddr: Source address to be split into bank/local address
   *  @param mode: BANK for bank address, LOCAL for bank local address
   *  The 'stride' parameter describes interleaving scheme among banks. In particular,
   *  'stride' refers to the number of consecutive addresses that map to the same bank.
   *  This is typically equal to the number of columns, if the bank is storing
   *  a matrix that is accessed column-wise.
   *  stride == 1 corresponds to round-robin interleaving
   */
  DFEVar bankAndLocalAddr(DFEVar srcAddr, AddrMode mode) {
    if (banks == 1) {
      switch (mode) {
        case BANK:
          return constant.var(0);
        case LOCAL:
          return srcAddr;
        default:
          return srcAddr;
      }
    } else {
      if (stride == 1) {  // Specialize for round-robin interleaving
        if (MathUtils.isPowerOf2(banks)) {
          switch (mode) {
            case BANK:
              return srcAddr.slice(0, MathUtils.bitsToAddress(banks));
            case LOCAL:
              return srcAddr.slice(MathUtils.bitsToAddress(banks), MathUtils.bitsToAddress(size/banks));
            default:
              return srcAddr;
          }
        } else {
          KernelMath.DivModResult d = KernelMath.divMod(srcAddr.cast(dfeUInt(MathUtils.bitsToAddress(size))), constant.var(dfeUInt(MathUtils.bitsToAddress(banks)), banks));
          switch (mode) {
            case BANK:
              return d.getQuotient().cast(dfeUInt(MathUtils.bitsToAddress(banks)));
            case LOCAL:
              return d.getRemainder();
            default:
              return srcAddr;
          }
        }
      } else {  // General (non round-robin) interleaving
        if (MathUtils.isPowerOf2(stride) & (MathUtils.isPowerOf2(banks))) {
            int stridebits = MathUtils.bitsToAddress(stride);
            int bankbits = MathUtils.bitsToAddress(banks);
            switch (mode) {
              case BANK:
                return srcAddr.slice(stridebits, bankbits);
              case LOCAL:
                DFEVar lsb = srcAddr.slice(0, stridebits);
                DFEVar msb = srcAddr.slice(stridebits + bankbits, MathUtils.bitsToAddress(size) - stridebits - bankbits);
                return msb.cat(lsb);
              default:
                return srcAddr;
            }
          } else {  // Fall back to general case if either stride or banks is not a power-of-2
          KernelMath.DivModResult addrByStride = KernelMath.divMod(srcAddr.cast(dfeUInt(MathUtils.bitsToAddress(size))), constant.var(dfeUInt(MathUtils.bitsToAddress(stride)), stride));
          switch(mode) {
            case BANK:
              DFEVar bankAddr = KernelMath.modulo(addrByStride.getQuotient(), banks);
              return bankAddr;
            case LOCAL:
              KernelMath.DivModResult addrByStrideBanks = KernelMath.divMod(srcAddr.cast(dfeUInt(MathUtils.bitsToAddress(size))), constant.var(dfeUInt(MathUtils.bitsToAddress(stride*banks)), stride*banks));
              DFEVar bankLocalAddr = addrByStride.getRemainder().cast(dfeUInt(MathUtils.bitsToAddress(size/banks))) + stride * (addrByStrideBanks.getQuotient().cast(dfeUInt(MathUtils.bitsToAddress(size/banks))));
              return bankLocalAddr;
            default:
              return srcAddr;
          }
        }
      } // Non round-robin interleaving
    }
  }

  DFEVar connectRport(DFEVar srcAddr) {
    DFEVar bank_local_addr = bankAndLocalAddr(srcAddr, AddrMode.LOCAL);
    DFEVar bank_addr = bankAndLocalAddr(srcAddr, AddrMode.BANK);
    DFEVar[] bank_local_rdata = new DFEVar[banks];
    for (int i=0; i<banks; i++) {
      bank_local_rdata[i] = m[i].read(bank_local_addr);
    }
    if (banks == 1) {
      return bank_local_rdata[0];
    } else {
      DFEVar rdata = control.mux(bank_addr, bank_local_rdata);
      if (dbg) {
        debug.simPrintf((srcAddr ^ stream.offset(srcAddr, -1)) !== constant.var(0), "raddr = %d (bank = %d, bank_local_addr = %d), rdata = %d, numBanks = %d\n", srcAddr, bank_addr, bank_local_addr, rdata, banks);
      }
      return rdata;
    }
  }

  void connectWport(DFEVar dstAddr, DFEVar data, DFEVar en) {
    connectWport(dstAddr, data, en, 0, 1);
  }

  /**
   *  Write a single value to this memory bank. The 'start' and 'stride' are used to restrict
   *  the number of banks to which this value could be written. This is useful when the value
   *  produced can only be written to a subset of the banks.
   *  @param dstAddr: DFEVar representing address (must decipher bank and local addr from this)
   *  @param data: Data to be written
   *  @param en: Write enable bit
   *  @param start: Starting bank to which this write port should be connected
   *  @param stride: Skip over these many banks when wiring write ports
   */
  void connectWport(DFEVar dstAddr, DFEVar data, DFEVar en, int start, int stride) {
    if (banks == 1) {
      m[0].write(dstAddr, data, en);
    } else {
      DFEVar bank_local_addr = bankAndLocalAddr(dstAddr, AddrMode.LOCAL);
      DFEVar bank_addr = bankAndLocalAddr(dstAddr, AddrMode.BANK);
      if (dbg) {
          debug.simPrintf(en, "waddr = %d (bank = %d, bank_local_addr = %d), wdata = %d, numBanks = %d, stride = %d\n", dstAddr, bank_addr, bank_local_addr, data, banks, this.stride);
      }
      for (int i=start; i<banks; i+=stride) {
        DFEVar wen = en & (bank_addr === i);
        m[i].write(bank_local_addr, data, wen);
      }
    }
  }

  DFEVector<DFEVar> connectRport(DFEVector<DFEVar> srcAddr) {
    DFEVar[] bank_local_rdata = new DFEVar[banks];
    if (banks != srcAddr.getSize()) {
      System.out.printf("ERROR: #banks = %d, Vector size = %d do not match!", banks, srcAddr.getSize());
      System.exit(-1);
    }
    for (int i=0; i<banks; i++) {
      DFEVar bank_local_addr = bankAndLocalAddr(srcAddr[i], AddrMode.LOCAL);
      bank_local_rdata[i] = m[i].read(bank_local_addr);
    }
    DFEVectorType<DFEVar> vectorType = new DFEVectorType<DFEVar>(type, banks);
    DFEVector<DFEVar> outstream = vectorType.newInstance(this);
    for (int i=0; i<banks; i++) {
      outstream[i] <== bank_local_rdata[i];
    }
    return outstream;
  }


  void connectWport(DFEVector<DFEVar> dstAddr, DFEVector<DFEVar> dstData, DFEVar en, int start, int stride) {
    connectWport(dstAddr, dstData, en);
  }

  void connectWport(DFEVector<DFEVar> dstAddr, DFEVector<DFEVar> dstData, DFEVar en) {
    for (int i=0; i<banks; i++) {
      DFEVar bank_local_addr = bankAndLocalAddr(dstAddr[i], AddrMode.LOCAL);
      m[i].write(bank_local_addr, dstData[i], en);
    }
  }

  void connectWport(DFEVector<DFEVar> dstAddr, DFEVector<DFEVar> dstData) {
    connectWport(dstAddr, dstData, constant.var(true));
  }
}
